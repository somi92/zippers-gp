<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1427929722354">{:repl-history {:ide [], :local [&quot;(at-index '(* (+ 1 2) (- (* 3 4) (+ 5 (+ 6 7)))) 122)&quot; &quot;(zip/next z)&quot; &quot;(println (zip/next z))&quot; &quot;(println (zip/node (zip/next z)))&quot; &quot;(println (zip/node (zip/next (zip/next z))))&quot; &quot;(seq? '1)&quot; &quot;(at-index '(* (+ 1 2) (- (* 3 4) (+ 5 (+ 6 7)))) 0)&quot; &quot;(at-index '(* (+ 1 2) (- (* 3 4) (+ 5 (+ 6 7)))) 1)&quot; &quot;(mod 2 13)&quot; &quot;(zip/next (zip/node z))&quot; &quot;(seq? (+ 2 3))&quot; &quot;(seq? '(+ 2 3))&quot; &quot;(seq? '(3))&quot; &quot;(seq? '3)&quot; &quot;(seq? 3)&quot; &quot;(zip/next (zip/next z))&quot; &quot;(zip/node (zip/next z))&quot; &quot;(zip/node z)&quot; &quot;(zip/node (zip/next (zip/next z)))&quot; &quot;(zip/node (zip/next (zip/next (zip/next z))))&quot; &quot;(zip/node (zip/next (zip/next (zip/next (zip/next z)))))&quot; &quot;(at-index '(* (+ 1 2) (- (* 3 4) (+ 5 (+ 6 7)))) 2)&quot; &quot;(at-index '(* (+ 1 2) (- (* 3 4) (+ 5 (inc 7)))) 2)&quot; &quot;(at-index '(* (inc 1) (- (* 3 4) (+ 5 (+ 6 7)))) 2)&quot; &quot;(at-index '(* (inc 1) (- (* 3 4) (+ 5 (+ 6 7)))) 1)&quot; &quot;(at-index '(* 1 (- (* 3 4) (+ 5 (inc 7)))) 2)&quot; &quot;(at-index '(* 1 (- (* 3 4) (+ 5 (inc 7)))) 1)&quot; &quot;(def g2 '(* 1 (- (* 3 4) (+ 5 (+ 6 7)))))&quot; &quot;(def z2 (zip/seq-zip g2))&quot; &quot;(zip/node (zip/next (zip/next (zip/next z2))))&quot; &quot;(zip/node (zip/next (zip/next z2)))&quot; &quot;(zip/node (zip/next z2))&quot; &quot;(zip/node (zip/next '(+ 1 2)))&quot; &quot;(zip/node (zip/next (+ 1 2)))&quot; &quot;function-table&quot; &quot;(use 'app.example :as ex)&quot; &quot;(require 'app.example\n         [:as ex])&quot; &quot;(require '[app.example :as ex])&quot; &quot;(ex/random-function)&quot; &quot;(random-terminal)&quot; &quot;(ex/random-code 5)&quot; &quot;(ex/random-code 1)&quot; &quot;(ex/random-code 3)&quot; &quot;(ex/random-code 2)&quot; &quot;(random-code 4)&quot; &quot;(random-code 2)&quot; &quot;(random-expression 3)&quot; &quot;(eval (random-expression 3))&quot; &quot;(def e (random-expression 3))&quot; &quot;(eval e)&quot; &quot;(use 'app.core)&quot; &quot;e&quot; &quot;(evalute e)&quot; &quot;(evalute t)&quot; &quot;(use 'app.core :reload)&quot; &quot;(error '(+ 2 3))&quot; &quot;(def e (random-expression 4))&quot; &quot;(def t (random-expression 4))&quot; &quot;t&quot; &quot;(eval t)&quot; &quot;(error t)&quot; &quot;(mutate '(2 3 4))&quot; &quot;(require '[app.core :refer [refresh]])&quot; &quot;(use '[app.core :refresh])&quot; &quot;(mutate t2)&quot; &quot;(crossover t1 t2)&quot; &quot;(use 'app.core :reload-all)&quot; &quot;(eval t2)&quot; &quot;(def t1 (random-expression 4))&quot; &quot;(eval t1)&quot; &quot;()&quot; &quot;(def t2 (random-expression 4))&quot; &quot;population&quot; &quot;(def population ['(- 17000 1) '(- 10 10) t1 t2])&quot; &quot;(fn [[err1 ind1] [err2 ind2]] (&lt; err1 err2))&quot; &quot;(fn [[err1 ind1] [err2 ind2]] (&lt; err1 err2) [1 2])&quot; &quot;(fn [[err1 ind1] [err2 ind2]] (&lt; err1 err2) [1 2 3])&quot; &quot;(println (fn [[err1 ind1] [err2 ind2]] (&lt; err1 err2) [1 2 3]))&quot; &quot;(println (fn [[err1 ind1] [err2 ind2]] (&lt; err1 err2) [1 2]))&quot; &quot;(println (fn [[err1 ind1] [err2 ind2]] (&lt; err1 err2) [[1 2] [1 2]]))&quot; &quot;(str (fn [[err1 ind1] [err2 ind2]] (&lt; err1 err2) [1 2 3]))&quot; &quot;(sort (fn [[err1 ind1] [err2 ind2]] (&lt; err1 err2) [1 2 3]))&quot; &quot;(sort (fn [[err1 ind1] [err2 ind2]] (&lt; err1 err2) [1 2 3 4]))&quot; &quot;(sort (fn [[err1 ind1] [err2 ind2]] (&lt; err1 err2) [[1 3] [4 3]]))&quot; &quot;(sort (fn [[err1 ind1] [err2 ind2]] (&lt; err1 err2) [[1 2 3] [12 45 5]]))&quot; &quot;(sort (fn [[err1 ind1] [err2 ind2]] (&lt; err1 err2) [[1 3] [12 45]]))&quot; &quot;(use 'app.example)&quot; &quot;(def t1 (random-code 4))&quot; &quot;t1&quot; &quot;(def t2 (random-code 4))&quot; &quot;t2&quot; &quot;(def population [t1 t2])&quot; &quot;(sort-by-error population)&quot; &quot;(map #(vector (error %) %) population)&quot; &quot;(sort (fn [[err1 ind1] [err2 ind2]] (&lt; err1 err2) '([1 '(+ 1 2)] [2 '(+ 3 4)])))&quot; &quot;(sort [4 3] [2 1])&quot; &quot;(sort &gt; [4 3] [2 1])&quot; &quot;(sort &gt; [[4 3] [2 1]])&quot; &quot;(sort [[4 3] [2 1]])&quot; &quot;(sort [[1 2] [2 1]])&quot; &quot;(use 'app.example.zipp-gp-example)&quot;], :remote []}}</component>
</project>